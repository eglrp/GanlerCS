# 复习提纲-2

[TOC]

## 正则语言的性质

### 泵定理

![](https://i.loli.net/2019/06/15/5d04f854090be43949.png)

证明$\{1^n;n\ is\ prime\}$不是正则语言：

> $\forall k \ge 1,\exist prime\ p > k$。令x,z=$\epsilon$，得到$s=y=1^p$。$xy^iz=1^{ip}$，当i等于p的时候$xy^iz=1^{p^2}$，不是素数。



### 等价性

满足如下条件的FA是等价的：

![](https://i.loli.net/2019/06/15/5d049009abc3652360.png)



1. 对于A的$q_i$和B的$q_j$，在接受同样输入后到达的状态要么都是FS，要么都是IS；
2. 如果$q_i$是初始状态，接受某种输入后也进入了FS，那么$q_j$必须也是初始状态，且接受同样输入后进入FS。



![](https://i.loli.net/2019/06/15/5d048fd08489495888.png)

如何解题：

- 找到两个FA的**初始状态**，从这两个状态开始，对其输入不同的符号，然后看是不是满足1和2；
- 对于没有出现过的IS，继续执行上述步骤，直到没有新的IS出现或者不满足上述规则。

### 不可区分(Indistinguishable)

给定语言L和俩字符串x,y，对于z ∈ $\Sigma^*$，xz,yz要么同时在L中，要么同时不在L中，则称x和y不可区分，写作：$x\equiv_L y$。

- 不可区分是一种**等价关系**，所有具有相同等价关系的是一个等价类，拥有有限个等价类即为正则语言；
- 从DFA的角度来看，xz和yz进入M的时候，最后状态相同。

> 换而言之，等价关系就是对于输入(x, y)可以被状态机的同一状态所接受。

### 最小化

![img](https://www.gatevidyalay.com/wp-content/uploads/2018/08/Minimization-of-DFA.png)

#### Myhill-Nerode 定理

![](https://i.loli.net/2019/06/15/5d04ed840513139063.png)

- 画一个表格只看左下边(对角线不看)；
- 标记所有(P, Q)，where P和Q一个是FS，一个是IS；
- 对于所有未标记的pair，对其输入同样的字母(任意一个即可)，若得到的新的pair被标记过，那么把当前pair也标记一下；
- 如果这一轮进行了任意标记，那么重复上一步骤，直到不再有任何新的标记；
- 返回到原来的DFA的图，将未被标记的pair合并；

![](https://i.loli.net/2019/06/15/5d04ef61068cb13391.png)



![](https://i.loli.net/2019/06/15/5d04efc260c0952821.png)



#### 用MN定理证明正则语言

> 可以先画FA，再证明状态有限。

给定语言L和俩字符串x,y，对于z ∈ $\Sigma^*$，xz,yz要么同时在L中or not，则称x和y不可区分，写作：$x\equiv_L y$。

- 如果一个语言是正则的话，$\equiv_L$的等价类数目是有限的；
- 接受语言L的最小自动机的状态数目等于$\equiv_L$ 中等价类的数目；

> 例如，由可以被 3 整除的二進位數組成的語言是正則的。有三個等價類 3 - 被 3 除的時候餘數是 0, 1 和 2 的數。接受這個語言的極小自動機有對應於等價類的三個狀態。

## 作业

#### 给出正则文法，画DFA

注意点：

- 先建立基本状态；
- 对于不存在的的输入导入到一个$\empty$状态中；
- 检查每个状态的输入要完整；
- 冲突的情况就加状态。比如$A\to aB|aS|bQ$，那么就把输入a引入到新状态BS中。

![](https://i.loli.net/2019/06/15/5d04f49878cd357840.png)

#### DFA转RE

注意一旦到达终结符就弄个单独输出；

#### 证明是否是正则语言

- 画出DFA|NFA；(最管用)
- 右线性和左线性不能重叠；
- 写出正则表达式；
- MN(从FA出发，或者找到一个较好的划分标准)

## CFG&PDA

### CFG

> CFG -> CFL -> PDA

![](https://i.loli.net/2019/06/16/5d05cb8354fe698926.png)



#### 语法树

> 语法树是专门用来解析CFG产生的string的。

#### 例子

- 最左派生：所有的非终结符从最左边开始推导；
- 最右派生：所有的非终结符从最右边开始推导；
- 边缘：叶子从左到右的排序；

![](/Users/ganler-mac/Desktop/5d05cefca1c9671628.png)

#### 消除歧义性：CNF

> 中间可以有"|"

$$
A\to BC\\
A\to a\\
S\to \epsilon
$$

#### CFG->CNF

![](https://i.loli.net/2019/06/16/5d05d42247e6470540.png)

- 如果最右边有S，那么加一个状态$S'\to S$；
- 消除null状态；
- 消除Unit Production：形如$A\to B,B\to C$；
- 分解$A\to BCD$这种状态，直到都是$A\to BC$；
- 将$A\to aB$弄成$A\to A'B,A'\to a$。

### PDA

> Recognize CFL;
>
> PDA=FA+Stack;

#### 画PDA

![](https://i.loli.net/2019/06/16/5d05d92a69a3f28961.png)

