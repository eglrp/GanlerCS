# 连续情况下的信息熵

[TOC]

## 连续情况下

#### 信息熵

$$
H(X)=-\sum _k p(x_k)\triangle x\log p(x_x)\triangle x\\
\lim_{k\to \infin,\triangle x\to 0} H(X)=-\int p(x)\log p(x)dx-\int p(x)\lim_{\triangle x\to 0}\log \triangle xdx=\\h(X)-(-\infin)
$$

可见，要描述一组连续随机变量，所需要的信息量往往是无穷大的。

#### 微分熵(也叫绝对熵)

$$
h(X)=-\int p(x)\log p(x)dx
$$

> **注意，微分熵不一定大于0。**

#### 联合微分熵

$$
h(X,Y)=-\int\int p(x,y)\log p(x,y)dxdy
$$

#### 条件微分熵

$$
h(X|Y)=-\int p(y)\int p(x|y) \log p(x|y) dxdy
$$

#### 正态分布微分熵

对于一个随机变量X，其上界就是正态分布微分熵。
$$
h(X)=\frac{1}{2}\log 2\pi e\sigma^2
$$

#### 连续取值的随机变量的互信息

> 使用互信息。

$$
I(X;Y)=\int\int p(x,y)\log\frac{p(x)p(y)}{p(x,y)}dxdy
$$

## 渐进等同分割性质

#### 大数定理

$$
\frac{\sum^{n\to \infin}_i X_i}{n}\to p
$$

#### 渐进等同分割

- 对已有的数据进行分割成多个序列，当序列足够长的时候，一部分序列就显现出一种典型的性质；
- 序列中各个符号的出现频数非常接近于<u>各自出现的概率</u>，这些序列的出现概率趋于相等，其之和接近1，那么就称这些序列为**典型序列**。



$X_1\sim X_n$是独立同分布的随机变量，有$P(X_1,X_2,\cdots,X_n)=\prod P(X_i)$。(切记，信息熵有负号)
$$
-\frac{1}{n}\log p(X_1,X_2,\cdots,X_n)\to -\frac{\log\prod^n P(X_i)}{n} \to H(X)
$$
典型序列满足：
$$
2^{-n(H(X)+\epsilon)}\le p(x_1,x_2,\cdots,x_n) \le 2^{-n(H(X)-\epsilon)}
$$

#### 典型序列性质

1.
$$
  if\ x\in A_\epsilon^{(n)},H(X)-\epsilon \le -\frac{1}{n}\log p(x) \le H(X)+\epsilon
$$

2. n足够大的时候，我们几乎只看到典型序列；

3.
$$
|A_\epsilon^{(n)}|\in [(1-\epsilon)2^{n(H(X)-\epsilon)}, 2^{n(H(X)+\epsilon)}]
$$

## 香农编码定理

#### 估计定长编码

$X^n$是独立同分布的离散随机变量构成的序列，总有一个足够大的n，可以满足其对二进制的的一一映射。
$$
E\left[\frac{l(X^n)}{n}\right] \le H(X)+\epsilon
$$
![](https://i.loli.net/2019/05/16/5cdd524134ce324846.png)



## 指标

#### 码率

$$
\frac{H(x)}{\bar l(x)}
$$

信息熵除以平均码长。二元码的编码效率同码率。对于N元码的编码效率：$\frac{H(x)/\bar l(x)}{\log N}$。

#### 自信息方差

$$
\sigma(X)=D(I(X))=\sum p(x)\left(\log p(x)\right)^2-H(X)^2
$$



## 码字

#### 同阶码

各码字的传输时间相同。

#### 等长码

所有码字的长度相同。

#### 非奇异码

码字之间不重复；

#### 唯一可译码

任何一个码字不是其他码字的排列

#### 及时码/前缀码

任何一个码不是其他码字的前缀

#### 包含关系

**<u>所有码字</u>**  包含  **<u>非奇异码</u>**  包含  **<u>唯一可译码</u>**  包含  **<u>及时码</u>**。

> 汉字在没有标点符号的情况下不是唯一可译码。莫尔斯密码也是。

#### 前缀码的充要条件：Kraft不等式

$l_i$是D进制前缀码的码长。其必满足：
$$
\sum_i D^{-l_i}\le 1
$$

#### 最优前缀码定理(香农第一定理)

> 最优：码字的平均长度最短。

$$
H_D(X)\le L^*\le H_D(X)+1
$$

> 定长编码的**容差**是$\epsilon$，但在工程实现的时候需要更大的缓冲区。变长编码对应的最优前缀码在工程上实现迅速，但是问题在于其**容差**恒定为1，当n很大的时候会造成些许浪费。

#### 变长编码和定长编码的比较

> 把边长编码分组，当组数无限大的时候就和定长一样了。

先进行分组，尽量让各组满足$L^*=H(X)$，然后这样就可以把容差分配到多组中。
$$
\frac{H(X_1,\cdots,H_n)}{n}\le L^*_n < \frac{H(...)+1}{n}
$$


