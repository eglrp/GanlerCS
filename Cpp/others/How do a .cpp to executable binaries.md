# How do a `.cpp` to executable binaries

This article is not going to tell you the detials of compiling or linking. It just helps you to feel the pipline when compiling a `.cpp` file to an executable binary. Hope you enjoy that.

My device:

```shell
Mac@ganler  ~  g++ -v
Using built-in specs.
COLLECT_GCC=g++-7
COLLECT_LTO_WRAPPER=/usr/local/Cellar/gcc@7/7.4.0/libexec/gcc/x86_64-apple-darwin18.2.0/7.4.0/lto-wrapper
Target: x86_64-apple-darwin18.2.0
Configured with: ../configure --build=x86_64-apple-darwin18.2.0 --prefix=/usr/local/Cellar/gcc@7/7.4.0 --libdir=/usr/local/Cellar/gcc@7/7.4.0/lib/gcc/7 --enable-languages=c,c++,objc,obj-c++,fortran --program-suffix=-7 --with-gmp=/usr/local/opt/gmp --with-mpfr=/usr/local/opt/mpfr --with-mpc=/usr/local/opt/libmpc --with-isl=/usr/local/opt/isl --with-system-zlib --enable-checking=release --with-pkgversion='Homebrew GCC 7.4.0' --with-bugurl=https://github.com/Homebrew/homebrew-core/issues --disable-nls --disable-multilib --with-native-system-header-dir=/usr/include --with-sysroot=/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk
Thread model: posix
gcc version 7.4.0 (Homebrew GCC 7.4.0)
```



## 3 things

We do 3 things to convert a `.cpp` to binaries:

- Preprocess;
- Compile(including generating object code from assembler);
- Link;

![C++ compilation process](http://faculty.cs.niu.edu/~mcmahon/CS241/Images/compile.png)

## Preprocess

#### Theory

Preprocessing does with “`#`”.  “`.cpp`”s are passed to the compiler(only once) while “`.h`”s are copied to “`.cpp`”s where they are included(any times).

For each “`.cpp`”, the preprocessor will build a **translation unit** and do 3 things(generally): 

​	1. Find “`#include`” and copy them to where they're included; 

​	2. Find conditional compilation blocks like `#ifdef` and do with what they mean.

​	3. macro replacements like `#define int32_t int`.

After that, compilation starts.

#### Practice: to see expanded code after preprocessing

```shell
 Mac@ganler  ~  cd Desktop
 Mac@ganler  ~/Desktop  mkdir cpp_compiling
 Mac@ganler  ~/Desktop  cd cpp_compiling
 Mac@ganler  ~/Desktop/cpp_compiling  touch helloworld.cpp
 Mac@ganler  ~/Desktop/cpp_compiling  nano helloworld.cpp
```

The content of  `helloworld.cpp`:

```c++
#include <iostream>
int main() {
    std::cout << "Hello world\n";
}
```

To see what has been done in a translation unit(the "code" after preprocessing), we use `-E` with `g++`, along with `-o` to make sure the name of  the outcoming "code" is what we want:

```shell
g++ -E helloworld.cpp -o magic.ii
wc -l magic.ii
```

then we see **26756**(in my device) lines of code(as "iostream" is very huge and it is included).

## Compile

#### Theory

The expanded source code file produced by the C++ preprocessor is compiled into the assembly language for the platform.

Then the assembler code generated by the compiler is assembled into the object code for the platform.

#### Practice: to see the assembly code:

```shell
g++ -S helloworld.cpp -o magic.s
wc -l magic.s # 180
```

#### Practice: to see the machine code:

```shell
g++ -c helloworld.cpp -o magic.o
```

As it's a binary file...

## Link

#### Theory

The object code file generated by the assembler is linked together with the object code files for any library functions used to produce an executable file.

## Reference

[1](http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/compile.html)